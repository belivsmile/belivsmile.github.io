# Git基础
## 创建仓库
  git init 项目名称       #创建空仓库
  cd 项目名称; git init   #基于已有项目创建仓库
## 配置仓库
```
git config --local 配置名 '值'     #本地配置（缺省），当前仓库有效
git config --global 配置名 '值'    #全局配置，所有仓库有效
git config --local list           #显示本地配置
git config --global list          #显示全局配置
```

## 理解工作区、暂存区、版本库的关系
工作区：当前工作的目录。  
暂存区：包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名、文件的状态信息（时间戳、文件长度等），文件的内容并不存储其中，而是保存在对象库（.git/objects）中，文件索引建立了文件和对象库中对象实体之间的映射。  
版本库：仓库当前的工作分支。  
使用关系：工作区更新提交至暂存区，暂存区的更新提交至版本库。  

## 理解HEAD
指向仓库当前工作分支最近一次commit对象的ID。  
HEAD^、HEAD^^：HEAD的父commit对象ID、HEAD的父父commit对象ID。  
HEAD&sim;1、HEAD&sim;2：HEAD的父commit对象ID、HEAD的父父commit对象ID。  

## 理解.git
HEAD文件：存放仓库的工作分支。  
config文件：存放仓库的配置。  
refs目录/tags：仓库的所有标签（也称里程碑）。  
refs目录/heads：仓库的所有分支。  
refs目录/heads/分支名：存放分支的最近一次提交对象的ID。  
refs目录/objects：存放仓库的所有对象。 

## 理解commit、tree、blob对象之间的关系
一个commit对象：对应一个tree对象，该tree对象存放着当前commit对象对应时间点的仓库分支快照。  
一个tree对象：包含tree对象（代表一个文件夹）和blob对象（代表一个文件）。  
一个blob对象：存放一个文件的内容，针对相同内容的文件，使用唯一的blob对象存储。  
当暂存区更新时，响应文件或文件夹对应的blob或tree对象也被Git管理更改。  

## 理解分离头指针detached HEAD
处在一个没有分支的状态（执行：git checkout commitID），此时HEAD不会指向任何分支，若切换到其他分支后，分离头指针下的提交可能被Git垃圾回收。  
用途：用于做一些尝试性更改，若效果不好就切换分支丢弃；若效果好，则基于detached HEAD最近一次的commit对象ID创建新分支。  

## 理解.gitignore文件
配置不需要Git管理的文件。    

## 常用命令
仓库分支查看/创建/删除
```
git branch -v                      #查看本地的分支列表
git branch -av                     #查看本地和远端的分支列表
git branch 新分支名 commitID        #基于commit对象ID创建新分支
git branch -D 分支名                #删除分支
git checkout -b 新分支名 commitID   #基于commit对象ID创建新分支，并切换至该新分支
git checkout -b 新分支名 分支名     #基于已有分支创建新分支，并切换至该新分支
git checkout 分支名                #切换分支
```
仓库分支内容更改
```
git status 	                      #查看当前仓库分支的状态
git add/rm 文件1 文件2             #将工作区指定添加/修改/删除的文件提交至暂存区
git add -u                        #将工作区所有添加/修改的文件提交至暂存区
git mv 旧文件名 新文件名           #文件重命名并提交暂存区
git commit -m'提交说明'            #将暂存区更改提交至HEAD
git commit -am'提交说明'           #将工作区更改同时提交至暂存区和HEAD
```
提交历史查看 
```
git log                           #查看仓库当前分支提交历史
git log 分支名                     #查看仓库指定分支的提交历史
git log --oneline                 #每条提交历史使用一行显示
git log -n2                       #只显示最近的2条提交历史
git log -all                      #查看仓库所有分支提交历史
git log -all --graph              #树形结构化地显示仓库所有分支提交历史
gitk                              #图形界面化地显示仓库当前分支提交历史
gitk -all                         #图形界面化地显示仓库所有分支提交历史
```
工作区/暂存区/版本库恢复
```
git reset --hart                  #清除工作区和暂存区所有更改，即恢复到仓库当前分支最近一次提交的状态
git reset --hart commitID         #工作区、暂存区、HEAD均恢复到仓库当前分支指定commit对象ID的状态
git reset HEAD                    #将暂存区恢复成和HEAD一样
git reset HEAD -- 文件1 文件2      #将暂存区指定文件恢复成和HEAD一样
git checkout -- 文件1 文件2        #将工作区指定文件恢复成和暂存区一样
```
对象查看
```
git cat-file -t ID                #查看对象ID的类型，如commit、tag、tree、blob等
git cat-file -p ID                #查看对象ID的内容
```
内容差异对比
```
git diff                          #比较工作区与暂存区的差异
git diff -- 文件1 文件2            #比较工作区与暂存区指定文件的差异
git diff --cached                 #比较暂存区与HEAD的差异
git diff commitID1 commitID2      #比较两个commit对象ID的差异
git diff 分支1 分支2               #比较两个分支的差异
git diff 分支1 分支2 -- 文件1 文件2 #比较两个分支指定文件的差异
```
工作区贮藏
```
git stash                         #将工作区的更改存起来，常用于临时紧急任务处理情形
git stash list                    #查看存起来的工作区
git stash apply                   #恢复工作区的更改，不推荐使用
git stash pop                     #将存起来的工作区更改移出，并恢复，推荐使用
```
提交消息更改
```
git commit --amend                 #进入编辑模式，更改当前分支最近一次commit的提交说明
git rebase -i commitID的父commitID  #进入交互界面编辑模式，找到commitID将其pick命令改为reword命令，wq!保存退出，进入编辑模式，更改commitID的提交说明；进入交互界面编辑模式，找到要合并至commitID的commitID将其pick命令改为squash命令，wq!保存退出，进入编辑模式，更改commitID的提交说明
注意：修改commit提交行为建议只在自己的本地分支中操作，若已集成到团队的git分支上，则禁止修改commit提交说明，避免影响团队使用
```

# Github实践
## 传输协议
传输协议：本地协议（哑协议、智能协议）、http/https协议（智能协议）、ssh协议（智能协议）。  
哑协议（传输进度不可见）：/path/to/repo.git。  
智能协议（传输进度可见）：file:///path/to/repo.git 。  
http/https协议：https://git-server.com:port/path/to/repo.git 。  
ssh协议：user@git-server.com:path/to/repo.git。  
备注：哑协议，传输进度不可见；智能协议，传输进度可见。

## 本地仓库同步至Github
```
git remote -v                                                         #查看远端仓库
git remote add 远端仓库名 https://git-server.com:port/path/to/repo.git #将远端仓库备份到本地
git clone https://git-server.com:port/path/to/repo.git 仓库目录        #将远端仓库备份到本地，这里默认的远端仓库名为origin
git remote remove 远端仓库名                                           #删除远端仓库
git remote rename 旧远端仓库名 新远端仓库名                             #重命名远端仓库名称
git push 远端仓库名 分支                                               #将本地分支push到远端仓库
git push 远端仓库名 --all                                              #将本地所有分支push到远端仓库
git fetch 远端仓库名                                                   #将远端所有分支fetch到本地
git fetch 远端仓库名 分支                                              #将远端分支fetch到本地
git checkout -b 本地分支名 远端仓库名/分支名                            #基于远端仓库分支创建本地分支，并切换到本地分支
git merge 远端仓库名/分支                                              #将远端分支merge到本地分支
git merge --allow-unrelated-historise 远端仓库名/分支                  #允许不相干的远端分支merge到本地分支
git pull                                                              #pull等价于fetch+merge
```

## 远端仓库分支多人协作开发
以下情况造成的本地分支push失败处理：  
多人修改不同文件：git fetch；git merge。  
多人修改同一文件的不同区域：git fetch；git merge。  
多人修改同一文件的同一区域：git fetch；git merge；合理编辑冲突区域；git commit。  
同时变更了文件名和文件内容：git fetch；git merge。  
同一文件改成不同文件名：git fetch；git merge；git rm删除冲突的文件名；git commit。  
结论：若不产生冲突，git pull都能解决；若产生冲突，git pull后，需要处理冲突点。  

## 创建个人博客
Fork仓库：https://github.com/barryclark/jekyll-now





